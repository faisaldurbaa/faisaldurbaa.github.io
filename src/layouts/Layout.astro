---
import Seo, { type Props as SeoProps } from '../components/Seo.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import Analytics from '../components/Analytics.astro';
import { ClientRouter } from 'astro:transitions';

interface Frontmatter {
  title: string;
  description: string;
  heroImage?: string;
}

interface Props {
  seo?: SeoProps;
  frontmatter?: Frontmatter;
}

const { seo: seoProp, frontmatter } = Astro.props;

const seo = seoProp || {
  title: frontmatter?.title ?? '',
  description: frontmatter?.description ?? '',
  image: frontmatter?.heroImage,
};
---
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width" />
  <link rel="icon" type="image/png" href="/favicon.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'" />
  <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" /></noscript>
  <Seo {...seo} />
  <Analytics />
</head>
<body class="relative bg-gradient-to-br from-[#d6e7f0] via-[#eaf2f7] to-[#d6e7f0] text-gray-900 font-sans flex flex-col min-h-screen overflow-x-hidden">
  <ClientRouter fallback="animate" />
  <!-- Glassmorphism Background Orbs -->
  <div class="fixed inset-0 -z-10 overflow-hidden">
    <!-- Large central focal point -->
    <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[900px] h-[700px] bg-gradient-radial from-[#c8dde8]/50 via-[#d6e7f0]/30 to-transparent blur-3xl"></div>
    
    <!-- Top-right orb -->
    <div class="absolute -top-20 -right-20 w-80 h-80 bg-gradient-radial from-[#bfdbf7]/40 to-transparent blur-2xl"></div>
    
    <!-- Bottom-left orb -->
    <div class="absolute -bottom-20 -left-20 w-96 h-96 bg-gradient-radial from-[#c8dde8]/35 to-transparent blur-3xl"></div>
    
    <!-- Top-left accent -->
    <div class="absolute top-20 left-20 w-64 h-64 bg-gradient-radial from-[#d1e7f0]/45 to-transparent blur-xl"></div>
  </div>
  
  <Header />
  <main class="flex-grow pt-20 relative z-0" transition:animate="fade">
    <slot />
  </main>
  <Footer />
  <script>
    const dataChartKey = '__dataChartInit';
    const existingInit = window[dataChartKey];

    if (existingInit && typeof existingInit.refresh === 'function') {
      existingInit.refresh();
    } else {
      let observer = null;
      let chartModulePromise = null;
      let annotationModulePromise = null;

      const loadChartModules = async () => {
        if (!chartModulePromise) {
          chartModulePromise = import('chart.js/auto');
        }
        if (!annotationModulePromise) {
          annotationModulePromise = import('chartjs-plugin-annotation');
        }

        const [chartModule, annotationModule] = await Promise.all([
          chartModulePromise,
          annotationModulePromise,
        ]);
        const Chart = chartModule.default || chartModule.Chart || chartModule;
        const annotationPlugin = annotationModule.default || annotationModule;

        if (annotationPlugin && !Chart.__annotationRegistered) {
          Chart.register(annotationPlugin);
          Chart.__annotationRegistered = true;
        }

        return Chart;
      };

      const initChart = async (canvas) => {
        if (canvas.dataset.chartReady === 'true') return;

        try {
          const Chart = await loadChartModules();
          const type = canvas.dataset.chartType;
          const data = JSON.parse(canvas.dataset.chartData || '{}');
          const datasets = Array.isArray(data.datasets) ? data.datasets : [];

          if (!type || datasets.length === 0) return;

          const existingChart = Chart.getChart(canvas);
          if (existingChart) {
            existingChart.destroy();
          }

          const options = {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                display: datasets.length > 1,
                position: 'top',
                labels: { font: { family: 'Inter, sans-serif' }, color: '#1f2937' },
              },
              tooltip: {
                backgroundColor: '#ffffff',
                titleColor: '#1f2937',
                bodyColor: '#4b5563',
                borderColor: '#e5e7eb',
                borderWidth: 1,
                padding: 10,
                cornerRadius: 8,
                displayColors: true,
              },
              annotation: data.annotation ? data.annotation : {},
            },
            scales: {
              x: {
                grid: { display: false },
                ticks: {
                  font: { family: 'Inter, sans-serif', size: 10 },
                  color: '#4b5563',
                  maxRotation: 45,
                  minRotation: 45,
                },
              },
              y: {
                grid: { color: '#e5e7eb', borderDash: [5, 5] },
                ticks: {
                  font: { family: 'Inter, sans-serif', size: 10 },
                  color: '#4b5563',
                },
              },
            },
            animation: { duration: 1000, easing: 'easeInOutCubic' },
          };

          new Chart(canvas, {
            type: type,
            data: data,
            options: options,
          });

          canvas.dataset.chartReady = 'true';
          const loadingDiv = document.getElementById(`${canvas.id}-loading`);
          if (loadingDiv) loadingDiv.style.display = 'none';
          canvas.style.opacity = '1';
        } catch (err) {
          console.error('Failed to load chart modules', err);
          const loadingDiv = document.getElementById(`${canvas.id}-loading`);
          if (loadingDiv) loadingDiv.textContent = 'Chart failed to load';
        }
      };

      const setupObserver = () => {
        if (!('IntersectionObserver' in window)) {
          document.querySelectorAll('canvas[data-chart-type]').forEach((canvas) => {
            if (canvas instanceof HTMLCanvasElement) {
              initChart(canvas);
            }
          });
          return;
        }

        if (!observer) {
          observer = new IntersectionObserver((entries, observerInstance) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                setTimeout(() => {
                  initChart(entry.target);
                  observerInstance.unobserve(entry.target);
                }, 100);
              }
            });
          }, { threshold: 0.1 });
        }

        document.querySelectorAll('canvas[data-chart-type]').forEach((canvas) => {
          if (!(canvas instanceof HTMLCanvasElement)) return;
          if (canvas.dataset.chartReady === 'true') return;
          if (canvas.dataset.chartObserved === 'true') return;
          canvas.dataset.chartObserved = 'true';
          observer.observe(canvas);
        });
      };

      const runSetup = () => {
        setupObserver();
      };

      window[dataChartKey] = { refresh: runSetup };

      document.addEventListener('astro:page-load', runSetup);
      document.addEventListener('astro:after-swap', runSetup);
      if (document.readyState !== 'loading') runSetup();
    }
  </script>
</body>
</html>
