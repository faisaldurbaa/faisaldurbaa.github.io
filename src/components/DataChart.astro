---
import type { ChartData } from 'chart.js';

export interface Props {
  type: 'line' | 'bar';
  data: ChartData;
  title: string;
  id: string;
}

const { type, data, title, id } = Astro.props;
---
<div class="w-full bg-white/50 border border-gray-200/50 rounded-lg shadow-sm p-4 my-8">
  <h3 class="text-lg md:text-xl font-semibold mb-4 text-gray-800 text-center">{title}</h3>
  <div class="relative h-72 md:h-96">
    <canvas 
      id={id}
      data-chart-type={type}
      data-chart-data={JSON.stringify(data)}
      class="opacity-0 transition-opacity duration-500"
    ></canvas>
    <div id={`${id}-loading`} class="absolute inset-0 flex items-center justify-center bg-gray-100 rounded">
      <div class="text-gray-500">Loading chart...</div>
    </div>
  </div>
</div>

<script>
  const initChart = async (canvas: HTMLCanvasElement) => {
    // Dynamically import Chart.js only when needed
    const [{ Chart, registerables }, annotationPlugin] = await Promise.all([
      import('chart.js'),
      import('chartjs-plugin-annotation')
    ]);
    
    Chart.register(...registerables, annotationPlugin.default);
    const type = canvas.dataset.chartType as 'line' | 'bar';
    const data = JSON.parse(canvas.dataset.chartData || '{}');

    if (!type || !data) return;

    const existingChart = Chart.getChart(canvas);
    if (existingChart) {
      existingChart.destroy();
    }

    const options = {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'index' as const,
        intersect: false,
      },
      plugins: {
        legend: {
          display: data.datasets.length > 1,
          position: 'top' as const,
          labels: { font: { family: 'Inter, sans-serif' }, color: '#1f2937' },
        },
        tooltip: {
          backgroundColor: '#ffffff',
          titleColor: '#1f2937',
          bodyColor: '#4b5563',
          borderColor: '#e5e7eb',
          borderWidth: 1,
          padding: 10,
          cornerRadius: 8,
          displayColors: true,
        },
        annotation: data.annotation ? data.annotation : {}
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: {
            font: { family: 'Inter, sans-serif', size: 10 },
            color: '#4b5563',
            maxRotation: 45,
            minRotation: 45,
          },
        },
        y: {
          grid: { color: '#e5e7eb', borderDash: [5, 5] },
          ticks: {
            font: { family: 'Inter, sans-serif', size: 10 },
            color: '#4b5563',
          },
        },
      },
      animation: { duration: 1000, easing: 'easeInOutCubic' as const },
    };

    new Chart(canvas, {
      type: type,
      data: data,
      options: options,
    });

    // Hide loading and show chart
    const loadingDiv = document.getElementById(`${canvas.id}-loading`);
    if (loadingDiv) loadingDiv.style.display = 'none';
    canvas.style.opacity = '1';
  };

  const setupObserver = () => {
    const observer = new IntersectionObserver((entries, observerInstance) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          setTimeout(() => {
            initChart(entry.target as HTMLCanvasElement);
            observerInstance.unobserve(entry.target);
          }, 100);
        }
      });
    }, { threshold: 0.1 });

    document.querySelectorAll('canvas[data-chart-type]').forEach(canvas => {
      observer.observe(canvas);
    });
  }

  // Run on initial page load
  setupObserver();
  // Run on view transitions
  document.addEventListener('astro:after-swap', setupObserver);
</script>
