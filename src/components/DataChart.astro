---
import type { ChartData } from 'chart.js';

export interface Props {
  type: 'line' | 'bar';
  data: ChartData;
  title: string;
  id: string;
}

const { type, data, title, id } = Astro.props;
---
<div class="w-full bg-white/50 border border-gray-200/50 rounded-lg shadow-sm p-4 my-8">
  <h3 class="text-lg md:text-xl font-semibold mb-4 text-gray-800 text-center">{title}</h3>
  <div class="relative h-72 md:h-96">
    <canvas 
      id={id}
      data-chart-type={type}
      data-chart-data={JSON.stringify(data)}
      class="opacity-0 transition-opacity duration-500"
    ></canvas>
    <div id={`${id}-loading`} class="absolute inset-0 flex items-center justify-center bg-gray-100 rounded">
      <div class="text-gray-500">Loading chart...</div>
    </div>
  </div>
</div>

<script>
  const initChart = async (canvas: HTMLCanvasElement) => {
    try {
      const [{ default: Chart }, annotationPluginModule] = await Promise.all([
        import('chart.js/auto'),
        import('chartjs-plugin-annotation')
      ]);
      
      const annotationPlugin = (annotationPluginModule as any).default || annotationPluginModule;
      if (annotationPlugin) {
        Chart.register(annotationPlugin);
      }

      const type = canvas.dataset.chartType as 'line' | 'bar';
      const data = JSON.parse(canvas.dataset.chartData || '{}');

      if (!type || !data) return;

      const existingChart = Chart.getChart(canvas);
      if (existingChart) {
        existingChart.destroy();
      }

      const options = {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index' as const,
          intersect: false,
        },
        plugins: {
          legend: {
            display: data.datasets.length > 1,
            position: 'top' as const,
            labels: { font: { family: 'Inter, sans-serif' }, color: '#1f2937' },
          },
          tooltip: {
            backgroundColor: '#ffffff',
            titleColor: '#1f2937',
            bodyColor: '#4b5563',
            borderColor: '#e5e7eb',
            borderWidth: 1,
            padding: 10,
            cornerRadius: 8,
            displayColors: true,
          },
          annotation: data.annotation ? data.annotation : {}
        },
        scales: {
          x: {
            grid: { display: false },
            ticks: {
              font: { family: 'Inter, sans-serif', size: 10 },
              color: '#4b5563',
              maxRotation: 45,
              minRotation: 45,
            },
          },
          y: {
            grid: { color: '#e5e7eb', borderDash: [5, 5] },
            ticks: {
              font: { family: 'Inter, sans-serif', size: 10 },
              color: '#4b5563',
            },
          },
        },
        animation: { duration: 1000, easing: 'easeInOutCubic' as const },
      };

      new Chart(canvas, {
        type: type,
        data: data,
        options: options,
      });

      // Hide loading and show chart
      const loadingDiv = document.getElementById(`${canvas.id}-loading`);
      if (loadingDiv) loadingDiv.style.display = 'none';
      canvas.style.opacity = '1';
    } catch (err) {
      console.error('Failed to load chart modules', err);
      const loadingDiv = document.getElementById(`${canvas.id}-loading`);
      if (loadingDiv) loadingDiv.textContent = 'Chart failed to load';
    }
  };

  const setupObserver = () => {
    const observer = new IntersectionObserver((entries, observerInstance) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          setTimeout(() => {
            initChart(entry.target as HTMLCanvasElement);
            observerInstance.unobserve(entry.target);
          }, 100);
        }
      });
    }, { threshold: 0.1 });

    document.querySelectorAll('canvas[data-chart-type]').forEach(canvas => {
      observer.observe(canvas);
    });
  }

  // Run on initial page load
  setupObserver();
  // Run on view transitions
  document.addEventListener('astro:after-swap', setupObserver);
</script>
